// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

use crate::committee::Committee;
use crate::data::{IN_MEMORY_BLOCKS, IN_MEMORY_BLOCKS_BYTES};
use crate::runtime;
use crate::runtime::JoinHandle;
use crate::stat::{histogram, DivUsize, HistogramSender, PreciseHistogram};
use crate::types::{format_authority_index, AuthorityIndex};
use prometheus::{
    register_counter_vec_with_registry, register_histogram_vec_with_registry,
    register_int_counter_vec_with_registry, register_int_counter_with_registry,
    register_int_gauge_vec_with_registry, register_int_gauge_with_registry, CounterVec,
    HistogramVec, IntCounter, IntCounterVec, IntGauge, IntGaugeVec, Registry,
};
use std::net::SocketAddr;
use std::ops::AddAssign;
use std::sync::atomic::Ordering;
use std::sync::Arc;
use std::time::Duration;
use tabled::{Table, Tabled};
use tokio::sync::mpsc::Sender;
use tokio::time::Instant;

const LATENCY_SEC_BUCKETS: &[f64] = &[
    0.1, 0.25, 0.5, 0.75, 1., 1.25, 1.5, 1.75, 2., 2.5, 5., 10., 20., 30., 60., 90.,
];

/// Metrics collected by the benchmark.
pub const BENCHMARK_DURATION: &str = "benchmark_duration";
pub const LATENCY_S: &str = "latency_s";
pub const LATENCY_SQUARED_S: &str = "latency_squared_s";

#[derive(Clone)]
pub struct Metrics {
    pub benchmark_duration: IntCounter,
    pub latency_s: HistogramVec,
    pub latency_squared_s: CounterVec,
    pub committed_leaders_total: IntCounterVec,
    pub leader_timeout_total: IntCounter,
    pub inter_block_latency_s: HistogramVec,

    pub block_store_unloaded_blocks: IntCounter,
    pub block_store_loaded_blocks: IntCounter,
    pub block_store_entries: IntCounter,
    pub block_store_cleanup_util: IntCounter,

    pub wal_mappings: IntGauge,

    pub core_lock_util: IntCounter,
    pub core_lock_enqueued: IntCounter,
    pub core_lock_dequeued: IntCounter,

    pub block_handler_pending_certificates: IntGauge,
    pub block_handler_cleanup_util: IntCounter,

    pub commit_handler_pending_certificates: IntGauge,

    pub missing_blocks: IntCounterVec,
    pub blocks_suspended: IntCounter,
    pub block_sync_requests_sent: IntCounterVec,
    pub block_sync_requests_received: IntCounterVec,

    pub transaction_certified_latency: HistogramSender<Duration>,
    pub certificate_committed_latency: HistogramSender<Duration>,
    pub transaction_committed_latency: HistogramSender<Duration>,

    pub proposed_block_size_bytes: HistogramSender<usize>,
    pub proposed_block_transaction_count: HistogramSender<usize>,
    pub proposed_block_vote_count: HistogramSender<usize>,

    pub connection_latency_sender: Vec<HistogramSender<Duration>>,
    pub connected_nodes: IntGauge,

    pub utilization_timer: IntCounterVec,

    pub threshold_clock_round: IntGauge,
    pub commit_round: IntGauge,
    pub blocks_per_commit_count: HistogramSender<usize>,
    pub sub_dags_per_commit_count: HistogramSender<usize>,
    pub block_commit_latency: HistogramSender<Duration>,
    pub block_receive_latency: HistogramVec,

    pub code_scope_latency: HistogramVec,
}

pub struct MetricReporter {
    // When adding field here make sure to update
    // MetricsReporter::receive_all and MetricsReporter::run_report.
    pub transaction_certified_latency: HistogramReporter<Duration>,
    pub certificate_committed_latency: HistogramReporter<Duration>,
    pub transaction_committed_latency: HistogramReporter<Duration>,

    pub proposed_block_size_bytes: HistogramReporter<usize>,
    pub proposed_block_transaction_count: HistogramReporter<usize>,
    pub proposed_block_vote_count: HistogramReporter<usize>,

    pub connection_latency: VecHistogramReporter<Duration>,

    pub global_in_memory_blocks: IntGauge,
    pub global_in_memory_blocks_bytes: IntGauge,

    pub blocks_per_commit_count: HistogramReporter<usize>,
    pub block_commit_latency: HistogramReporter<Duration>,
    pub sub_dags_per_commit_count: HistogramReporter<usize>,
}

pub struct HistogramReporter<T> {
    pub histogram: PreciseHistogram<T>,
    gauge: IntGaugeVec,
}

pub struct VecHistogramReporter<T> {
    histograms: Vec<(PreciseHistogram<T>, String)>,
    gauge: IntGaugeVec,
}

impl Metrics {
    pub fn new(registry: &Registry, committee: Option<&Committee>) -> (Arc<Self>, MetricReporter) {
        let (transaction_certified_latency_hist, transaction_certified_latency) = histogram();
        let (certificate_committed_latency_hist, certificate_committed_latency) = histogram();
        let (transaction_committed_latency_hist, transaction_committed_latency) = histogram();

        let (proposed_block_size_bytes_hist, proposed_block_size_bytes) = histogram();
        let (proposed_block_transaction_count_hist, proposed_block_transaction_count) = histogram();
        let (proposed_block_vote_count_hist, proposed_block_vote_count) = histogram();
        let (block_commit_latency_hist, block_commit_latency) = histogram();
        let (blocks_per_commit_count_hist, blocks_per_commit_count) = histogram();
        let (sub_dags_per_commit_count_hist, sub_dags_per_commit_count) = histogram();

        let commitee_size = committee.map(Committee::len).unwrap_or_default();
        let (connection_latency_hist, connection_latency_sender) = (0..commitee_size)
            .map(|peer| {
                let (hist, sender) = histogram();
                (
                    (
                        hist,
                        format_authority_index(peer as AuthorityIndex).to_string(),
                    ),
                    sender,
                )
            })
            .unzip();
        let reporter = MetricReporter {
            transaction_certified_latency: HistogramReporter::new_in_registry(
                transaction_certified_latency_hist,
                registry,
                "transaction_certified_latency",
            ),
            certificate_committed_latency: HistogramReporter::new_in_registry(
                certificate_committed_latency_hist,
                registry,
                "certificate_committed_latency",
            ),
            transaction_committed_latency: HistogramReporter::new_in_registry(
                transaction_committed_latency_hist,
                registry,
                "transaction_committed_latency",
            ),

            proposed_block_size_bytes: HistogramReporter::new_in_registry(
                proposed_block_size_bytes_hist,
                registry,
                "proposed_block_size_bytes",
            ),
            proposed_block_transaction_count: HistogramReporter::new_in_registry(
                proposed_block_transaction_count_hist,
                registry,
                "proposed_block_transaction_count",
            ),
            proposed_block_vote_count: HistogramReporter::new_in_registry(
                proposed_block_vote_count_hist,
                registry,
                "proposed_block_vote_count",
            ),

            connection_latency: VecHistogramReporter::new_in_registry(
                connection_latency_hist,
                "peer",
                registry,
                "connection_latency",
            ),
            block_commit_latency: HistogramReporter::new_in_registry(
                block_commit_latency_hist,
                registry,
                "block_commit_latency",
            ),
            blocks_per_commit_count: HistogramReporter::new_in_registry(
                blocks_per_commit_count_hist,
                registry,
                "blocks_per_commit_count",
            ),
            sub_dags_per_commit_count: HistogramReporter::new_in_registry(
                sub_dags_per_commit_count_hist,
                registry,
                "sub_dags_per_commit_count",
            ),

            global_in_memory_blocks: register_int_gauge_with_registry!(
                "global_in_memory_blocks",
                "Number of blocks loaded in memory",
                registry,
            )
            .unwrap(),
            global_in_memory_blocks_bytes: register_int_gauge_with_registry!(
                "global_in_memory_blocks_bytes",
                "Total size of blocks loaded in memory",
                registry,
            )
            .unwrap(),
        };
        let metrics = Self {
            benchmark_duration: register_int_counter_with_registry!(
                BENCHMARK_DURATION,
                "Duration of the benchmark",
                registry,
            )
            .unwrap(),
            latency_s: register_histogram_vec_with_registry!(
                LATENCY_S,
                "Buckets measuring the end-to-end latency of a workload in seconds",
                &["workload"],
                LATENCY_SEC_BUCKETS.to_vec(),
                registry,
            )
            .unwrap(),
            latency_squared_s: register_counter_vec_with_registry!(
                LATENCY_SQUARED_S,
                "Square of total end-to-end latency of a workload in seconds",
                &["workload"],
                registry,
            )
            .unwrap(),
            committed_leaders_total: register_int_counter_vec_with_registry!(
                "committed_leaders_total",
                "Total number of (direct or indirect) committed leaders per authority",
                &["authority", "commit_type"],
                registry,
            )
            .unwrap(),
            inter_block_latency_s: register_histogram_vec_with_registry!(
                "inter_block_latency_s",
                "Buckets measuring the inter-block latency in seconds",
                &["workload"],
                LATENCY_SEC_BUCKETS.to_vec(),
                registry,
            ).unwrap(),
            leader_timeout_total: register_int_counter_with_registry!(
                "leader_timeout_total",
                "Total number of leader timeouts",
                registry,
            )
            .unwrap(),

            block_store_loaded_blocks: register_int_counter_with_registry!(
                "block_store_loaded_blocks",
                "Blocks loaded from wal position in the block store",
                registry,
            )
            .unwrap(),
            block_store_unloaded_blocks: register_int_counter_with_registry!(
                "block_store_unloaded_blocks",
                "Blocks unloaded from wal position during cleanup",
                registry,
            )
            .unwrap(),
            block_store_entries: register_int_counter_with_registry!(
                "block_store_entries",
                "Number of entries in block store",
                registry,
            )
            .unwrap(),
            block_store_cleanup_util: register_int_counter_with_registry!(
                "block_store_cleanup_util",
                "block_store_cleanup_util",
                registry,
            )
            .unwrap(),

            wal_mappings: register_int_gauge_with_registry!(
                "wal_mappings",
                "Number of mappings retained by the wal",
                registry,
            )
            .unwrap(),

            core_lock_util: register_int_counter_with_registry!(
                "core_lock_util",
                "Utilization of core write lock",
                registry,
            )
            .unwrap(),
            core_lock_enqueued: register_int_counter_with_registry!(
                "core_lock_enqueued",
                "Number of enqueued core requests",
                registry,
            )
            .unwrap(),
            core_lock_dequeued: register_int_counter_with_registry!(
                "core_lock_dequeued",
                "Number of dequeued core requests",
                registry,
            )
            .unwrap(),

            block_handler_pending_certificates: register_int_gauge_with_registry!(
                "block_handler_pending_certificates",
                "Number of pending certificates in block handler",
                registry,
            )
            .unwrap(),
            block_handler_cleanup_util: register_int_counter_with_registry!(
                "block_handler_cleanup_util",
                "block_handler_cleanup_util",
                registry,
            )
            .unwrap(),

            commit_handler_pending_certificates: register_int_gauge_with_registry!(
                "commit_handler_pending_certificates",
                "Number of pending certificates in commit handler",
                registry,
            )
            .unwrap(),

            missing_blocks: register_int_counter_vec_with_registry!(
                "missing_blocks",
                "Number of missing blocks per authority",
                &["authority"],
                registry,
            )
            .unwrap(),
            block_sync_requests_sent: register_int_counter_vec_with_registry!(
                "block_sync_requests_sent",
                "Number of block sync requests sent per authority",
                &["authority"],
                registry,
            )
            .unwrap(),
            block_sync_requests_received: register_int_counter_vec_with_registry!(
                "block_sync_requests_received",
                "Number of block sync requests received per authority and whether they have been fulfilled",
                &["authority", "fulfilled"],
                registry,
            )
            .unwrap(),

            utilization_timer: register_int_counter_vec_with_registry!(
                "utilization_timer",
                "Utilization timer",
                &["proc"],
                registry,
            )
            .unwrap(),

            threshold_clock_round: register_int_gauge_with_registry!(
                "threshold_clock_round",
                "The current threshold clock round. We only advance to a new round when a quorum of parents have been synced.",
                registry,
            ).unwrap(),

            commit_round: register_int_gauge_with_registry!(
                "commit_round",
                "The last committed leader round number",
                registry,
            ).unwrap(),

            connected_nodes: register_int_gauge_with_registry!(
                "connected_nodes",
                "The number of connected nodes",
                registry,
            ).unwrap(),

            blocks_suspended: register_int_counter_with_registry!(
                "blocks_suspended",
                "The number of blocks that got suspended due to missing references",
                registry
            ).unwrap(),

            block_receive_latency: register_histogram_vec_with_registry!(
                "block_receive_latency",
                "The time it took for a block to reach our node",
                &["authority"],
                registry
            ).unwrap(),

            code_scope_latency: register_histogram_vec_with_registry!(
                "code_scope_latency",
                "Time it takes for a code block to process",
                &["proc"],
                registry
            ).unwrap(),

            transaction_certified_latency,
            certificate_committed_latency,
            transaction_committed_latency,

            proposed_block_size_bytes,
            proposed_block_transaction_count,
            proposed_block_vote_count,

            connection_latency_sender,
            block_commit_latency,
            blocks_per_commit_count,
            sub_dags_per_commit_count
        };

        (Arc::new(metrics), reporter)
    }
}

pub trait AsPrometheusMetric {
    fn as_prometheus_metric(&self) -> i64;
}

impl<T: Ord + AddAssign + DivUsize + Copy + Default + AsPrometheusMetric> HistogramReporter<T> {
    pub fn new_in_registry(
        histogram: PreciseHistogram<T>,
        registry: &Registry,
        name: &str,
    ) -> Self {
        let gauge = register_int_gauge_vec_with_registry!(name, name, &["v"], registry).unwrap();

        Self { histogram, gauge }
    }

    pub fn report(&mut self) -> Option<()> {
        let [p50, p90, p99] = self.histogram.pcts([500, 900, 990])?;
        self.gauge
            .with_label_values(&["p50"])
            .set(p50.as_prometheus_metric());
        self.gauge
            .with_label_values(&["p90"])
            .set(p90.as_prometheus_metric());
        self.gauge
            .with_label_values(&["p99"])
            .set(p99.as_prometheus_metric());
        self.gauge
            .with_label_values(&["sum"])
            .set(self.histogram.total_sum().as_prometheus_metric());
        self.gauge
            .with_label_values(&["count"])
            .set(self.histogram.total_count() as i64);
        None
    }

    pub fn clear_receive_all(&mut self) {
        self.histogram.clear_receive_all();
    }
}

impl<T: Ord + AddAssign + DivUsize + Copy + Default + AsPrometheusMetric> VecHistogramReporter<T> {
    pub fn new_in_registry(
        histograms: Vec<(PreciseHistogram<T>, String)>,
        label: &str,
        registry: &Registry,
        name: &str,
    ) -> Self {
        let gauge =
            register_int_gauge_vec_with_registry!(name, name, &[label, "v"], registry).unwrap();

        Self { histograms, gauge }
    }

    pub fn report(&mut self) {
        for (histogram, label) in self.histograms.iter_mut() {
            let Some([p50, p90, p99]) = histogram.pcts([500, 900, 990]) else {
                continue;
            };
            self.gauge
                .with_label_values(&[label, "p50"])
                .set(p50.as_prometheus_metric());
            self.gauge
                .with_label_values(&[label, "p90"])
                .set(p90.as_prometheus_metric());
            self.gauge
                .with_label_values(&[label, "p99"])
                .set(p99.as_prometheus_metric());
            self.gauge
                .with_label_values(&[label, "sum"])
                .set(histogram.total_sum().as_prometheus_metric());
            self.gauge
                .with_label_values(&[label, "count"])
                .set(histogram.total_count() as i64);
        }
    }

    pub fn clear_receive_all(&mut self) {
        self.histograms
            .iter_mut()
            .for_each(|(hist, _)| hist.clear_receive_all());
    }
}

impl AsPrometheusMetric for Duration {
    fn as_prometheus_metric(&self) -> i64 {
        self.as_micros() as i64
    }
}

impl AsPrometheusMetric for usize {
    fn as_prometheus_metric(&self) -> i64 {
        *self as i64
    }
}

pub struct MetricReporterHandle {
    handle: JoinHandle<()>,
    stop: Sender<()>,
}

impl MetricReporterHandle {
    pub async fn shutdown(self) {
        let _ = self.stop.send(()).await;
        let _ = self.handle.await;
    }
}

impl MetricReporter {
    pub fn start(self) -> MetricReporterHandle {
        let (stop, rx_stop) = tokio::sync::mpsc::channel(1);
        let handle = runtime::Handle::current().spawn(self.run(rx_stop));

        MetricReporterHandle { handle, stop }
    }

    pub fn clear_receive_all(&mut self) {
        self.transaction_certified_latency.clear_receive_all();
        self.certificate_committed_latency.clear_receive_all();
        self.transaction_committed_latency.clear_receive_all();

        self.proposed_block_size_bytes.clear_receive_all();
        self.proposed_block_transaction_count.clear_receive_all();
        self.proposed_block_vote_count.clear_receive_all();

        self.connection_latency.clear_receive_all();
        self.blocks_per_commit_count.clear_receive_all();
        self.block_commit_latency.clear_receive_all();
        self.sub_dags_per_commit_count.clear_receive_all();
    }
    async fn run(mut self, mut stop: tokio::sync::mpsc::Receiver<()>) {
        const REPORT_INTERVAL: Duration = Duration::from_secs(60);
        let mut deadline = Instant::now();

        let timer = tokio::time::sleep(REPORT_INTERVAL);
        tokio::pin!(timer);

        loop {
            tokio::select! {
                () = &mut timer => {
                    self.run_report().await;

                    deadline += REPORT_INTERVAL;
                    timer.as_mut().reset(deadline);
                },
                _ = stop.recv() => {
                    tracing::info!("Shutting down metrics reporter");
                    return;
                }
            }
        }
    }

    async fn run_report(&mut self) {
        self.global_in_memory_blocks
            .set(IN_MEMORY_BLOCKS.load(Ordering::Relaxed) as i64);
        self.global_in_memory_blocks_bytes
            .set(IN_MEMORY_BLOCKS_BYTES.load(Ordering::Relaxed) as i64);

        self.clear_receive_all();

        self.transaction_certified_latency.report();
        self.certificate_committed_latency.report();
        self.transaction_committed_latency.report();

        self.proposed_block_size_bytes.report();
        self.proposed_block_transaction_count.report();
        self.proposed_block_vote_count.report();

        self.connection_latency.report();

        self.block_commit_latency.report();
        self.blocks_per_commit_count.report();
        self.sub_dags_per_commit_count.report();
    }
}

pub fn print_network_address_table(addresses: &[SocketAddr]) {
    let table: Vec<_> = addresses
        .iter()
        .enumerate()
        .map(|(peer, address)| NetworkAddressTable {
            peer: format_authority_index(peer as AuthorityIndex),
            address: address.to_string(),
        })
        .collect();
    tracing::info!("Network address table:\n{}", Table::new(table));
}

pub trait UtilizationTimerExt {
    fn utilization_timer(&self) -> UtilizationTimer;
    fn owned_utilization_timer(&self) -> OwnedUtilizationTimer;
}

pub trait UtilizationTimerVecExt {
    fn utilization_timer(&self, label: &str) -> OwnedUtilizationTimer;
}

impl UtilizationTimerExt for IntCounter {
    fn utilization_timer(&self) -> UtilizationTimer {
        UtilizationTimer {
            metric: self,
            start: Instant::now(),
        }
    }

    fn owned_utilization_timer(&self) -> OwnedUtilizationTimer {
        OwnedUtilizationTimer {
            metric: self.clone(),
            start: Instant::now(),
        }
    }
}

impl UtilizationTimerVecExt for IntCounterVec {
    fn utilization_timer(&self, label: &str) -> OwnedUtilizationTimer {
        self.with_label_values(&[label]).owned_utilization_timer()
    }
}

pub struct UtilizationTimer<'a> {
    metric: &'a IntCounter,
    start: Instant,
}

pub struct OwnedUtilizationTimer {
    metric: IntCounter,
    start: Instant,
}

impl<'a> Drop for UtilizationTimer<'a> {
    fn drop(&mut self) {
        self.metric.inc_by(self.start.elapsed().as_micros() as u64);
    }
}

impl Drop for OwnedUtilizationTimer {
    fn drop(&mut self) {
        self.metric.inc_by(self.start.elapsed().as_micros() as u64);
    }
}

#[derive(Tabled)]
struct NetworkAddressTable {
    peer: char,
    address: String,
}
